// Custom Service Worker with Workbox
// This will be enhanced by next-pwa at build time

// Import Workbox from CDN (next-pwa will inject this properly)
importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.5.4/workbox-sw.js');

// Enable debug logging in development
if (workbox) {
  console.log('[SW] Workbox loaded successfully');
} else {
  console.log('[SW] Workbox failed to load');
}

// CRITICAL: Skip waiting and claim clients immediately
// This ensures new SW activates without waiting for old tabs to close
self.addEventListener('install', (event) => {
  console.log('[SW] Installing new service worker...');
  self.skipWaiting(); // Activate immediately
});

self.addEventListener('activate', (event) => {
  console.log('[SW] Activating new service worker...');
  event.waitUntil(
    (async () => {
      // Clean up old caches
      const cacheNames = await caches.keys();
      await Promise.all(
        cacheNames
          .filter(cacheName => cacheName !== workbox.core.cacheNames.precache)
          .map(cacheName => {
            console.log('[SW] Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          })
      );

      // Take control of all clients immediately
      await self.clients.claim();

      // Notify all clients that new SW is active
      const clients = await self.clients.matchAll({ type: 'window' });
      clients.forEach(client => {
        console.log('[SW] Notifying client about update:', client.id);
        client.postMessage({
          type: 'SW_UPDATED',
          message: 'New version available'
        });
      });
    })()
  );
});

// Listen for messages from the app
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    console.log('[SW] Received SKIP_WAITING message');
    self.skipWaiting();
  }
});

// Configure Workbox
if (workbox) {
  // Precache files generated by next-pwa
  workbox.precaching.precacheAndRoute(self.__WB_MANIFEST || []);

  // STRATEGY 1: HTML pages - NetworkFirst
  // Always try network first to get latest content
  workbox.routing.registerRoute(
    ({ request, url }) => {
      return (
        request.destination === 'document' ||
        request.mode === 'navigate' ||
        request.headers.get('accept')?.includes('text/html')
      );
    },
    new workbox.strategies.NetworkFirst({
      cacheName: 'html-cache',
      networkTimeoutSeconds: 5,
      plugins: [
        new workbox.expiration.ExpirationPlugin({
          maxEntries: 32,
          maxAgeSeconds: 24 * 60 * 60, // 24 hours
        }),
        new workbox.cacheableResponse.CacheableResponsePlugin({
          statuses: [0, 200],
        }),
      ],
    })
  );

  // STRATEGY 2: Next.js static assets - CacheFirst
  // These have hash in URL so they're immutable
  workbox.routing.registerRoute(
    ({ url }) => url.pathname.startsWith('/_next/static/'),
    new workbox.strategies.CacheFirst({
      cacheName: 'next-static-cache',
      plugins: [
        new workbox.expiration.ExpirationPlugin({
          maxEntries: 64,
          maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
        }),
      ],
    })
  );

  // STRATEGY 3: Images - CacheFirst
  workbox.routing.registerRoute(
    ({ request }) => request.destination === 'image',
    new workbox.strategies.CacheFirst({
      cacheName: 'image-cache',
      plugins: [
        new workbox.expiration.ExpirationPlugin({
          maxEntries: 64,
          maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        }),
      ],
    })
  );

  // STRATEGY 4: API routes - NetworkFirst with fallback
  workbox.routing.registerRoute(
    ({ url }) => url.pathname.startsWith('/api/'),
    new workbox.strategies.NetworkFirst({
      cacheName: 'api-cache',
      networkTimeoutSeconds: 5,
      plugins: [
        new workbox.expiration.ExpirationPlugin({
          maxEntries: 32,
          maxAgeSeconds: 5 * 60, // 5 minutes
        }),
        new workbox.cacheableResponse.CacheableResponsePlugin({
          statuses: [0, 200],
        }),
      ],
    })
  );

  // STRATEGY 5: Convex API - StaleWhileRevalidate
  workbox.routing.registerRoute(
    ({ url }) => url.origin === 'https://api.convex.cloud' || url.hostname.includes('convex'),
    new workbox.strategies.StaleWhileRevalidate({
      cacheName: 'convex-cache',
      plugins: [
        new workbox.expiration.ExpirationPlugin({
          maxEntries: 50,
          maxAgeSeconds: 60 * 60, // 1 hour
        }),
      ],
    })
  );

  // STRATEGY 6: Fonts and other static assets - CacheFirst
  workbox.routing.registerRoute(
    ({ request }) =>
      request.destination === 'font' ||
      request.destination === 'style' ||
      request.destination === 'script',
    new workbox.strategies.CacheFirst({
      cacheName: 'static-resources',
      plugins: [
        new workbox.expiration.ExpirationPlugin({
          maxEntries: 60,
          maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
        }),
      ],
    })
  );

  // Catch-all: NetworkFirst for everything else
  workbox.routing.setDefaultHandler(
    new workbox.strategies.NetworkFirst({
      cacheName: 'default-cache',
      networkTimeoutSeconds: 10,
    })
  );

  // Offline fallback page (optional)
  workbox.routing.setCatchHandler(async ({ event }) => {
    if (event.request.destination === 'document') {
      return caches.match('/') || Response.error();
    }
    return Response.error();
  });
}

console.log('[SW] Service Worker registered with custom strategies');
